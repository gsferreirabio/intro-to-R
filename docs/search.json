[
  {
    "objectID": "yourfunction.html",
    "href": "yourfunction.html",
    "title": "Writing your functions",
    "section": "",
    "text": "Maybe you want to automatize a process for which you cannot find an already written function, or maybe you want to customize a function to your needs. R enables you to write your own functions using function() and defining the set of steps that will be performed by this function. Of course, they can be stored in objects, which will then be treated as the names of your functions.\nLet’s create a function to calculate the median of a distribution. The median is a value that separates the distribution in half. In a distribution with an odd number of elements, the element in the center of this distribution (when sorted from minimum to maximum or the opposite) is the median.\n\nodd.dist &lt;- c(1, 3, 5, 7, 9)\nlength(odd.dist)/2\n\n[1] 2.5\n\n# because this is not an integer, we will round it upwards\nodd.dist[ceiling(length(odd.dist)/2)]\n\n[1] 5\n\n\nThis becomes a bit more difficult when the distribution has an even number of elements, because there is no single position at the middle. What is done then is to calculate the average between the values in the two positions before and after the center of the distribution.\n\neven.dist &lt;- c(2, 4, 6, 8)\nmedian(even.dist)  \n\n[1] 5\n\n\nFive is not a number in the even.dist, but is the mean between 4 and 6. Thus, a function to calculate the mean will require four steps: 1. order the sequence 2. check whether the sequence is even or odd 3a. if it is odd, select the number in the center position 3b. if it is even, calculate the mean between the numbers before and after the center position\nIt is always useful to check if each step in your code successfully runs by itself. Let’s do this:\n\n# Step 1: Order the sequence\nnew.seq &lt;- c(1, 5, 3, 9, 7, 11)\nsort(new.seq)\n\n[1]  1  3  5  7  9 11\n\n# Step 2: Odd or even?\nlength(even.dist)%%2 == 0  ## dividing even.dist by 2 leaves nothing\n\n[1] TRUE\n\nlength(odd.dist)%%2 == 0\n\n[1] FALSE\n\n# Step 3a: if odd, select the number in the center position\nodd.dist[length(odd.dist)/2]\n\n[1] 3\n\n# Step 3b: if even, calculate the mean between the numbers before \n## and after the center position\nbef &lt;- even.dist[length(even.dist)/2]\naft &lt;- even.dist[1 + length(even.dist)/2]\n(bef + aft)/2\n\n[1] 5\n\n\nNow we can put all those steps together in a single function and use it to calculate the median of the new.seq and the even.dist objects.\n\ncalculate.median &lt;- \n  function(x) {\n    odd.even &lt;- length(x)%%2\n    ## we are going to use if/else statements\n    if (odd.even == 0) {  \n      (sort(x)[length(x)/2] + sort(x)[1 + length(x)/2])/2\n    }\n    else sort(x)[ceiling(length(x)/2)]\n  }\n\ncalculate.median(new.seq)\n\n[1] 6\n\ncalculate.median(even.dist)\n\n[1] 5\n\n\nFinally, you might want to save this function so that you can load it in another script, without the need to rewriting it all over. To save() and load() a function (or any object, actually), use:\n\nsave(calculate.median, file = \"calculate.median.R\")\n\n# and to load it in another session\nload(file = \"calculate.median.R\")",
    "crumbs": [
      "Basics in R",
      "Writing your functions"
    ]
  },
  {
    "objectID": "subsetting.html",
    "href": "subsetting.html",
    "title": "Subsetting",
    "section": "",
    "text": "Subsetting is a way to extract parts of an object based on some condition. This is very useful when working with large datasets, as it allows you to focus on specific subsets of data that meet certain criteria. Let’s load the size-meas.csv dataset to illustrate this. We can use head() to inspect it’s contents:\n\nhead(size.meas)\n\n             Clade                 Species       Specimen MiL   JL  SCm   SCL\n1    Bothremydidae    Cearachelys_placidoi BSP-1976-I-160  NA 31.9 42.9 219.4\n2 Carettochelyidae Carettochelys_insculpta         SDZ-sn  NA 43.3 57.0 253.3\n3 Carettochelyidae Carettochelys_insculpta         CRI-14  NA 64.5 84.8 485.3\n4 Carettochelyidae Carettochelys_insculpta      SMF-56626  NA 75.8 86.3 472.4\n5         Chelidae       Chelodina_colliei       CRI-4632  NA 48.2 54.4 274.0\n6         Chelidae       Chelodina_expansa      SMF-67838  NA 43.6 45.9 256.0\n\n\nThis dataset contains measurements of different specimens of turtles as well as information about their taxonomy. Let’s check how many different Clades are sampled in this dataset and how many Chelidae turtles are included. We can easily do that using the function unique() but we can also look at how many levels are in that column treating it as a factor.\n\nunique(size.meas$Clade)\n\n [1] \"Bothremydidae\"    \"Carettochelyidae\" \"Chelidae\"         \"Cheloniidae\"     \n [5] \"Chelydridae\"      \"Dermatemydidae\"   \"Dermochelyidae\"   \"Emydidae\"        \n [9] \"Geoemydidae\"      \"Kinosternidae\"    \"Pelomedusidae\"    \"Platysternidae\"  \n[13] \"Podocnemididae\"   \"Testudinidae\"     \"Trionychidae\"    \n\nlevels(as.factor(size.meas$Clade))\n\n [1] \"Bothremydidae\"    \"Carettochelyidae\" \"Chelidae\"         \"Cheloniidae\"     \n [5] \"Chelydridae\"      \"Dermatemydidae\"   \"Dermochelyidae\"   \"Emydidae\"        \n [9] \"Geoemydidae\"      \"Kinosternidae\"    \"Pelomedusidae\"    \"Platysternidae\"  \n[13] \"Podocnemididae\"   \"Testudinidae\"     \"Trionychidae\"    \n\nlength(size.meas$Clade[which(size.meas$Clade == \"Chelidae\")])\n\n[1] 35\n\n\nWhen we checked how many lines in that dataframe are identified as Chelidae in their Clade column, we made a subset of that dataframe. To subset data in R, you can use square brackets [] to specify the rows and columns you want to extract. The general syntax is data[rows, columns]. If you leave either the rows or columns section blank, R will return all rows or columns, respectively. For example, to extract all rows for the Clade column, you can use:\n\nClade &lt;- size.meas[, \"Clade\"]\nhead(Clade, n = 20)  ## show first 20 elements\n\n [1] \"Bothremydidae\"    \"Carettochelyidae\" \"Carettochelyidae\" \"Carettochelyidae\"\n [5] \"Chelidae\"         \"Chelidae\"         \"Chelidae\"         \"Chelidae\"        \n [9] \"Chelidae\"         \"Chelidae\"         \"Chelidae\"         \"Chelidae\"        \n[13] \"Chelidae\"         \"Chelidae\"         \"Chelidae\"         \"Chelidae\"        \n[17] \"Chelidae\"         \"Chelidae\"         \"Chelidae\"         \"Chelidae\"        \n\nsummary(Clade)\n\n   Length     Class      Mode \n      354 character character \n\n\nAnother way to subset data is by using logical conditions or the which() and subset() functions. For example, to extract all rows where the Clade is “Chelidae”, you can use:\n\nchelidae.logical &lt;- size.meas[size.meas$Clade == \"Chelidae\",]\nhead(chelidae.logical)\n\n      Clade               Species     Specimen  MiL   JL  SCm   SCL\n5  Chelidae     Chelodina_colliei     CRI-4632   NA 48.2 54.4 274.0\n6  Chelidae     Chelodina_expansa    SMF-67838   NA 43.6 45.9 256.0\n7  Chelidae     Chelodina_expansa   QM-J-84101   NA 49.3 52.0 355.6\n8  Chelidae Chelodina_longicollis   USNM-61091   NA   NA 26.9 200.7\n9  Chelidae     Chelodina_parkeri  USNM-231524   NA 42.0 46.7 250.7\n10 Chelidae     Chelus_fimbriatus MNHN-1897-67 39.7 56.8 63.5    NA\n\nchelidae.which &lt;- size.meas[which(size.meas$Clade == \"Chelidae\"), ]\nhead(chelidae.which)\n\n      Clade               Species     Specimen  MiL   JL  SCm   SCL\n5  Chelidae     Chelodina_colliei     CRI-4632   NA 48.2 54.4 274.0\n6  Chelidae     Chelodina_expansa    SMF-67838   NA 43.6 45.9 256.0\n7  Chelidae     Chelodina_expansa   QM-J-84101   NA 49.3 52.0 355.6\n8  Chelidae Chelodina_longicollis   USNM-61091   NA   NA 26.9 200.7\n9  Chelidae     Chelodina_parkeri  USNM-231524   NA 42.0 46.7 250.7\n10 Chelidae     Chelus_fimbriatus MNHN-1897-67 39.7 56.8 63.5    NA\n\nchelidae.subset &lt;- subset(size.meas, Clade == \"Chelidae\")\nhead(chelidae.subset)\n\n      Clade               Species     Specimen  MiL   JL  SCm   SCL\n5  Chelidae     Chelodina_colliei     CRI-4632   NA 48.2 54.4 274.0\n6  Chelidae     Chelodina_expansa    SMF-67838   NA 43.6 45.9 256.0\n7  Chelidae     Chelodina_expansa   QM-J-84101   NA 49.3 52.0 355.6\n8  Chelidae Chelodina_longicollis   USNM-61091   NA   NA 26.9 200.7\n9  Chelidae     Chelodina_parkeri  USNM-231524   NA 42.0 46.7 250.7\n10 Chelidae     Chelus_fimbriatus MNHN-1897-67 39.7 56.8 63.5    NA\n\nidentical(chelidae.logical, chelidae.which)  ## check if they are the same\n\n[1] TRUE\n\nidentical(chelidae.logical, chelidae.subset)  \n\n[1] TRUE\n\n\nThere are other functions that can help working with subsets of data. For example, you can create an intersection between objects using the intersect() function, or find elements that are in one object but not in another using the setdiff() function. Let’s see how many unique genera of turtles are in the Chelidae clade compared to the entire dataset.\n\nall.species &lt;- unique(size.meas$Species)  ## how many species in the entire dataset\nlength(all.species)\n\n[1] 147\n\nchelidae.species &lt;- unique(chelidae.logical$Species)  ## how many Chelidae species\nlength(chelidae.species)\n\n[1] 20\n\nintersect.species &lt;- intersect(all.species, chelidae.species)  ## species in both\nlength(intersect.species)\n\n[1] 20\n\nsetdiff.species &lt;- setdiff(all.species, chelidae.species)  ## species not in Chelidae\nlength(setdiff.species)\n\n[1] 127",
    "crumbs": [
      "Basics in R",
      "Subsetting"
    ]
  },
  {
    "objectID": "Rascalculator.html",
    "href": "Rascalculator.html",
    "title": "R as a calculator",
    "section": "",
    "text": "R is a very complete calculator that allows you to perform from simple arithmetic operations to solve complex equations. The basic arithmetic operators for addition, subtraction, multiplication and division in R are:\n\n2+2  ## addition\n\n[1] 4\n\n2-2  ## subtraction\n\n[1] 0\n\n2*2  ## multiplication\n\n[1] 4\n\n2/2  ## division\n\n[1] 1\n\n\nYou can pass multiple operations in a single line of code, but keep in mind that some operators have priorities over others, so use parameters to keep the desired operation order.\n\n2+3+5+10+25-2  ## multiple operations\n\n[1] 43\n\n2+3*4  ## multiplications and divisions are done first\n\n[1] 14\n\n2+10/5\n\n[1] 4\n\n3^2/2  ## but power comes first\n\n[1] 4.5\n\n# Parenthesis are useful to determine the order of operations\n3^(2/2)\n\n[1] 3\n\n\nR deals with large numbers using the e character followed by the number of positions the decimal point will move. If the number is positive, the decimal point moves to the right; if negative it moves to the left.\n\n1.2e3 \n\n[1] 1200\n\n1.2e-2 \n\n[1] 0.012\n\n\n\nLogical operators\nBoolean algebra (operations that return TRUE or FALSE values) can be done using the == (double equal signs = “equals to”) and != (“not” operator (!) followed by equal sign = “differs from”) logical operators:\n\n1 == 1\n\n[1] TRUE\n\n1 == 2\n\n[1] FALSE\n\n1 != 1\n\n[1] FALSE\n\n1 != 2\n\n[1] TRUE\n\n\nThe returned values from Boolean operations are TRUE and FALSE (always in capital letters), which can also be expressed by the single capital letters T and F, respectively.\n\nT == TRUE\n\n[1] TRUE\n\nF == FALSE\n\n[1] TRUE\n\n\n“Greater than” (&gt;), “smaller than or equal to” (&lt;=), “and” (&), “or” (|) are all logical operators that can be used in R.\n\n1 & 2 &gt; 3  ## 1 and 2 are greater than 0\n\n[1] FALSE\n\n1 | 10 &lt;= 5  ## 1 or 10 is smaller or equal to 5\n\n[1] TRUE\n\n\n\n\nAdditional signs\nTwo dots (:) can be used to create a sequence.\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n2.5:5.5\n\n[1] 2.5 3.5 4.5 5.5\n\n\nAnd the modulo operation (the remainder of a division) can be done using %%:\n\n2%%2\n\n[1] 0\n\n3%%2\n\n[1] 1\n\n\n\n\nMissing and null values\nMissing values in R are represented by the special object NA (“not available”). NAs reserve space in a vector, which is important to keep the original dimensions, but they can be very annoying when using some functions. We will see how to identify and deal with them in the Functions section. On the other hand, the special object NULL represents the absence of a value and indicates that an object contains no data. It can be used for example to create an object that will be fill with values later in a function to to remove the content of a preexisting object.",
    "crumbs": [
      "Basics in R",
      "R as a calculator"
    ]
  },
  {
    "objectID": "plotBasics.html",
    "href": "plotBasics.html",
    "title": "Basics of plotting in R",
    "section": "",
    "text": "Of course R is more than just a simple calculator. One of the great benefits of using R is producing high-quality plots to visualize your data and results. R has many built-in functions for plotting, and there are also several packages available that extend R’s plotting capabilities, such as ggplot2 and plotly.\nEven though those packages allow the user to create nice plots with less code, it is always good to know the basics of plotting in R using its built-in functions. Knowing the basics of the bult-in functions enables greater flexibility and control of the output.\nThe plot() function is one of the most commonly used functions for creating scatter plots, line plots, and other types of visualizations and it can be modified in many ways to customize the appearance of the plots. Let’s use the same dataset we used in the Subsetting section to create some basic plots.\nFirst, let’s create a simple scatter plot to visualize the relationship between the jaw length (JL) and straight carapace length (SCL) of the turtles in the dataset.\n\nplot(size.meas$JL, size.meas$SCL)\n\n\n\n\n\n\n\n\nThere is a lot of empty space in this graph, so we can limit the area shown using the xlim and ylim arguments to set the limits for the x and y axes, respectively.\n\nplot(size.meas$JL, size.meas$SCL, \n     xlim = c(15,95), \n     ylim = c(80,610))\n\n\n\n\n\n\n\n\nWe can also add labels to the axes, a title and a subtitle to the plot using the xlab, ylab, main, and sub arguments.\n\nplot(size.meas$JL, size.meas$SCL,\n     xlim = c(15,95), \n     ylim = c(80,610),\n     xlab = \"JL (mm)\",\n     ylab = \"SCL (mm)\",\n     main = \"Jaw Length vs. Carapace Length\",\n     sub = \"Published data from Ferreira et al. (2024). Biol. Lett.\")\n\n\n\n\n\n\n\n\nThe plot() function takes a great number of arguments (definitely check ?plot to see some of those), allowing you to change all the pieces of a graph. For example, changing color and shape of the points can be done using the col and pch arguments, respectively, and bty changes the layout of the graph. The family of arguments cex adjusts the scale of different elements of the plot, such as points, text, and labels.\n\nplot(size.meas$JL, size.meas$SCL,\n     xlim = c(15,95), \n     ylim = c(80,610),\n     xlab = \"JL (mm)\",\n     ylab = \"SCL (mm)\",\n     main = \"Jaw Length vs. Carapace Length\",\n     sub = \"Published data from Ferreira et al. (2024). Biol. Lett.\",\n     bty = \"l\",\n     col = \"blue\",\n     pch = 19,\n     cex = 1.5,\n     cex.main = 1.2,\n     cex.sub = 0.6,\n     cex.lab = 0.8,\n     cex.axis = 0.8)\n\n\n\n\n\n\n\n\nThere are different point types that can be used in R. You can check them all using the ?points help page. Here are some examples:\n\npar(mfrow = c(3,3), mai = c(0.5,0.3,0.3,0.3))  ## set the plotting area to a 2x3 grid\nfor (i in c(1:6, 21:23)) {\n  plot(size.meas$JL, size.meas$SCL,\n       xlim = c(15,95), \n       ylim = c(80,610),\n       xlab = \"\",\n       ylab = \"\",\n       main = paste(\"Point type:\", i),\n       pch = i,\n       col = \"blue\",\n       bg = \"red\",)\n}\n\n\n\n\n\n\n\n\nAbove I used a for loop to create multiple plots with different point types (a sequence including 1 to 6 and then 21, 22, and 23). Note that I used two arguments for changing the colors, col and bg. The col argument changes the color of the point border, while the bg argument changes the background color of the points (only for point types that have a background, such as 21 to 23 in this example).\npar() is a powerful function that can be used to control graphical parameters across all subsequent plots. In the example above, I used the argument mfrow = c(3,3) to set the plotting area to a 3x3 grid, allowing us to display multiple plots in a single figure.\nAfter creating a plot, you can add more elements to it using functions like points(), abline(), and text(). For example, let’s add a line separating larger turtles (SCL&gt;500 mm) from all others, highlighting species of the Clade Testudinidae with a different color and create a legend.\n\nplot(size.meas$JL, size.meas$SCL,\n     xlim = c(15,95),\n     ylim = c(80,610),\n     xlab = \"JL (mm)\",\n     ylab = \"SCL (mm)\",\n     main = \"Large vs. small testudinids\",\n     sub = \"Published data from Ferreira et al. (2024). Biol. Lett.\",\n     bty = \"l\",\n     col = \"lightgray\",\n     pch = 19,\n     cex = 1.2,\n     cex.sub = 0.6)\n\nabline(h = 500, col = \"darkred\", lty = 2)  ## add horizontal line at SCL = 500 mm\n\ntestudinidae &lt;- size.meas[size.meas$Clade == \"Testudinidae\", ]  ## subset Testudinidae\n\npoints(testudinidae$JL, testudinidae$SCL,\n       col = \"darkgreen\",\n       pch = 19,\n       cex = 1.2)\n\nlegend(\"topleft\",\n       legend = c(\"Testudinidae\", \"Other clades\"),\n       col = c(\"darkgreen\", \"lightgray\"),\n       pch = 19,\n       bty = \"n\",\n       cex = 0.8)",
    "crumbs": [
      "Data visualization",
      "Basics of plotting in R"
    ]
  },
  {
    "objectID": "occurrences.html",
    "href": "occurrences.html",
    "title": "Occurrence data from PaleoBioDB",
    "section": "",
    "text": "In the previous topic, we learned that it is possible to plot points on a map providing their coordinates as arguments in the points() function. However, plotting point-by-point would be meaningless when dealing with larger datasets and compiling their coordinates (or paleocoordinates) can be very time-consuming. Luckily, such data has, in many cases, been compiled by other researchers and, sometimes, made available in larger online repositories. Examples of those repositories are the Global Biodiversity Information Facility or GBIF for data on biodiversity and the Paleobiology Database or PaleoBioDB, specifically for occurrences of fossils. In this page, we will focus on the latter, exploring the R package paleobioDB to learn how to download and work with occurrence data of fossils using R.\nIn order to download occurrence data from PaleoBioDB, we will use the function pbdb_occurrences(). This function allows us to specify various parameters to filter the data we want to download, such as taxonomic group, time interval, geographic location, and more, and also to select which data to download. Let’s download a dataset composed of Cenozoic Testudines (turtles) occurrences:\n\ntestudines &lt;- pbdb_occurrences(base_name = \"Testudines\",\n                               interval = \"Cenozoic\",\n                               show = c(\"coords\", \"classext\", \"paleoloc\"),\n                               limit = \"all\", \n                               vocab = \"pbdb\")  ## vocab makes better names\n\n\ndim(testudines)\n\n[1] 5911   35\n\n\nThis dataset is composed of 5911 occurrences and it has 35 columns, with different types of information about each occurrence. The paleobioDB package includes a function for mapping the occurrences directly, called pbdb_map(). This function includes arguments for changing the mainland and ocean colors (col_int and col_ocean, respectively), and another (col_point) for changing the color gradient for the occurrences. Let’s explore this function and its arguments to plot the occurrences we just downloaded:\n\n# basic plot\npbdb_map(data = testudines,\n         main = \"Cenozoic Testudines occurrences\")\n\n\n\n\n\n\n\n# changing colors\npbdb_map(data = testudines,\n         main = \"Cenozoic Testudines occurrences\",\n         col_int = \"grey80\",\n         col_ocean = \"lightblue\",\n         col_point = c(\"lightyellow\", \"yellow\", \"orange\", \"red\"),\n         cex = 0.8)\n\n\n\n\n\n\n\n# using the color pallette from the package \"viridisLite\"\npbdb_map(data = testudines,\n         main = \"Cenozoic Testudines occurrences\",\n         col_int = \"grey80\",\n         col_ocean = \"lightblue\",\n         col_point = viridis(5))\n\n\n\n\n\n\n\n\nInstead of plotting single points for each occurrence, it is also possible to create richness maps, which can be useful to visualize areas with higher or lower taxonomic richness. To do so, we can use the function pbdb_map_richness, in which we need to select which taxonomic rank (e.g., species, genus, family, etc.) we want to consider. Let’s see how this works using different taxonomic ranks and color palettes:\n\n# by species\nmap.rich &lt;- pbdb_map_richness(data = testudines, \n                              rank = \"species\",\n                              res = 5,\n                              col_int = \"grey80\",\n                              col_ocean = \"lightblue\",\n                              col_rich = heat.colors(10),\n                              title = \"Species richness\")\n\n\n\n\n\n\n\n# by genera\nmap.rich &lt;- pbdb_map_richness(data = testudines, \n                              rank = \"genus\",\n                              res = 5,\n                              col_int = \"grey80\",\n                              col_ocean = \"lightblue\",\n                              col_rich = viridis(10),\n                              title = \"Genus richness\")\n\n\n\n\n\n\n\n# by family\nmap.rich &lt;- pbdb_map_richness(data = testudines, \n                              rank = \"family\",\n                              res = 5,\n                              col_int = \"grey80\",\n                              col_ocean = \"lightblue\",\n                              col_rich = map.pal(\"inferno\",10),\n                              title = \"Family richness\")\n\n\n\n\n\n\n\n\nThis page provided a brief overview of how to download and plot occurrence data from the Paleobiology Database using R. The paleobioDB package offers many more functions and options for working with paleontological data, so I encourage you to explore its documentation for further details and possibilities. Let’s take a look at some additional resources from the package.\n\n# Temporal range of taxa\ntemp.range &lt;- pbdb_temp_range(testudines,\n                              rank = \"family\",\n                              col = \"#AA55AA\") ## select color\n\n\n\n\n\n\n\n# Richness through time\nrich &lt;- pbdb_richness(testudines, \n                      rank = \"species\", \n                      ylab = \"Number of Species\", \n                      temporal_extent = c(0, 23)) ## define temporal extent\n\n\n\n\n\n\n\n# change color the resolution, default = 1\nrich &lt;- pbdb_richness(testudines, \n                      rank = \"genus\", ## change rank\n                      ylab = \"Number of Species\", \n                      temporal_extent = c(0, 23),\n                      res = 0.5, ## looks more detailed\n                      col = \"#A0A00F30\",\n                      bord = \"#A0A00F\")  \n\n\n\n\n\n\n\n# Patterns of origination and extinction\norigination &lt;- pbdb_orig_ext(testudines,\n                      rank = \"genus\",\n                      temporal_extent = c(0, 66),\n                      orig_ext = 1,  ## this argument defines whether origination\n                      res = 2)\n\n\n\n\n\n\n\nextinction &lt;- pbdb_orig_ext(testudines,\n                            rank = \"genus\",\n                            temporal_extent = c(0, 66),\n                            orig_ext = 2,  ## or extinction\n                            res = 2)\n\n\n\n\n\n\n\n\nWe can further explore the dataset downloaded from the PaleoBioDB with the package palaeoverse. Palaeoverse is an community initiative to share open-source tools for paleontological data analysis and visualization in R. It includes different packages, but here we are exploring only palaeoverse, which provides functions to prepare and explore paleontological data. Let’s see how we can use some of its functions to explore the testudines dataset:\n\ncenozoic.bins &lt;- time_bins(interval = \"Cenozoic\",\n                           plot = TRUE)\n\n\n\n\n\n\n\n\nThe package includes another useful function called bin_time which can be used to assign occurrences to time bins. This can be particularly useful for analyzing temporal patterns in the data using a common time framework. With this information, we can then run the function tax_range_time() to plot temporal ranges using our dataset.\n\nfamily_range &lt;- tax_range_time(subset(testudines, !is.na(family)),\n                               name = \"family\",\n                               plot = TRUE,\n                               plot_args = list(ylab = \"Families\",\n                                                pch = 15,\n                                                col = \"grey30\",\n                                                lty = 2))\n\n\n\n\n\n\n\n\npalaeorotate() is a function included in the palaeoverse package that allows us to calculate paleocoordinates for fossil occurrences based on their present-day coordinates and age. This can be particularly useful for ploting past distributions on paleogeographic maps. Let’s see how we can use this function with our testudines dataset, but before we proceed we need to assign the occurrences to a common framework of time bins, which can be done using the function bin_time(). Then we can use the look_up() function to convert the interval values derived from the PaleoBioDB into official numeric ages based on the intervals of the International Comission on Stratigraphy (ICS). This is useful for standardizing data from different sources. After this we can finally plot those occurrences per time bin and per paleocoordinates.\n\n# assing occurrences to time bins\ntestudines.binned &lt;- bin_time(occdf = testudines, \n                              bins = cenozoic.bins,\n                              method = \"majority\")\n# calculate paleocoordinates\ntestudines.palaeocoord &lt;- palaeorotate(testudines.binned, \n                                       age = \"bin_midpoint\")  ## using the midpoint of their range\n\n# convert to ICS intervals\ntestudines.palaeocoord &lt;- look_up(testudines.palaeocoord, \n                                  early_interval = \"early_interval\", \n                                  late_interval = \"late_interval\", \n                                  int_key = interval_key)\n\n# plot occurrences per time bin and per paleocoordinates\nplot(x = testudines.palaeocoord$interval_mid_ma,\n     y = testudines.palaeocoord$p_lat,\n     xlab = \"Time (Ma)\",\n     ylab = \"Palaeolatitude (\\u00B0)\",\n     xlim = c(66, 0), \n     xaxt = \"n\",\n     pch = 20,\n     cex = 1.5)\n\n# and we can add a geological time scale to the plot\naxis_geo(side = 1, \n         intervals = \"epoch\")",
    "crumbs": [
      "Ocurrence data from PaleoBioDB"
    ]
  },
  {
    "objectID": "maps.html",
    "href": "maps.html",
    "title": "Maps in R",
    "section": "",
    "text": "Maps are a powerful way to visualize spatial data in R. There are several packages available for creating maps, including ggplot2, leaflet, and sf. In the examples below, we will be using the package terrato create simple maps. terrahis a package for spatial data analysis that as extensive documentation and tutorials available at https://rspatial.org/. In addition, we will also be using the package geodata that provides access to various global spatial datasets, including elevation, climate, and administrative boundaries. Finally, paleogeographic reconstructions are very useful tools in geology and paleontology and we will be exploring that as well.\n\n# Load necessary libraries\nlibrary(terra)\nlibrary(geodata)\nlibrary(rayshader)\n\nThe function world() from the geodata package allows us to easily download data about country borders, which can be plotted using the plot() function.\n\ncountries &lt;- world(resolution = 5, path = \"maps\")  ## resolution between 1 and 5\nplot(countries)\n\n\n\n\n\n\n\n\nWe can also plot only the edges of the landmasses without country borders. To do so, we first need to add country map attributes to the countriesobject and then dissolve the the borders:\n\ncntry.codes &lt;- country_codes()\ncountries &lt;- merge(x = countries, \n                   y = cntry.codes, \n                   by.x = \"GID_0\", ## this info should be in the other df\n                   by.y = \"ISO3\",  ## that means the GID_0 and ISO3 are the same\n                   all.x = TRUE)\n\ncontinents &lt;- aggregate(countries, by = \"continent\")\nplot(continents, \n     \"continent\", \n     lwd = 0.2, \n     main = \"Global continents\")\n\n\n\n\n\n\n\n\nNote that each continent is a multi-part polygon including mainland and islands. Let’s look at Africa, for example:\n\ncontinents[1,]\n\n class       : SpatVector \n geometry    : polygons \n dimensions  : 1, 12  (geometries, attributes)\n extent      : -25.33125, 70.5575, -49.73083, 37.33509  (xmin, xmax, ymin, ymax)\n coord. ref. : +proj=longlat +datum=WGS84 +no_defs \n names       : continent     GID_0    NAME_0      NAME      ISO2  NAME_ISO\n type        :     &lt;chr&gt; &lt;logical&gt; &lt;logical&gt; &lt;logical&gt; &lt;logical&gt; &lt;logical&gt;\n values      :    Africa      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;\n NAME_FAO NAME_LOCAL SOVEREIGN UNREGION1 UNREGION2 agg_n\n    &lt;chr&gt;  &lt;logical&gt; &lt;logical&gt;     &lt;chr&gt;     &lt;chr&gt; &lt;int&gt;\n       NA       &lt;NA&gt;      &lt;NA&gt;        NA        NA    59\n\nafrica &lt;- continents[continents$continent == \"Africa\", ]\nplot(africa,\n     main = \"Africa\",\n     col = \"lightgreen\")\n\n\n\n\n\n\n\n\nIt is also possible to easily separate islands from the mainlands and plot one of them. Let’s do that and plot only mainlands of all continents:\n\nlargest &lt;- (order(expanse(continents), \n                  decreasing = TRUE))[1:length(unique(continents$continent))]\nmainlands &lt;- continents[largest, ]\nplot(mainlands, \n     \"continent\", \n     lwd = 0.2, \n     main = \"Continent mainlands\")\n\n\n\n\n\n\n\n\nWe can also plot elevation data using the elevation_global() function from the geodata package. This function allows us to download global elevation data at various resolutions. To do so, we will download elevation data at a resolution of 10 minutes, crop the data to the African mainland, and plot it:\n\nelevation &lt;- elevation_global(res = 10, \n                              path = \"maps\")\n# let's separate Africa\nafr_mainland &lt;- subset(mainlands, \n                       mainlands$continent == \"Africa\")\n# crop the elevation dataset based on afr_mainland\nelev_afr_mainland &lt;- crop(elevation, \n                          afr_mainland, \n                          mask = TRUE)\n# and now plot\nplot(elev_afr_mainland, \n     main = \"Elevation in mainland Africa\",\n     xlim = c(-20, 55), \n     ylim = c(-40, 40))\n\n\n\n\n\n\n\n\nHere, we just used the default color palette for elevation data. However, we can customize the colors using any palette’s:\n\nplot(elev_afr_mainland, \n     col = (gray(seq(0.9,0.1,length.out = 100))),\n     xlim = c(-20, 55), \n     ylim = c(-40, 40))\n\n\n\n\n\n\n\nplot(elev_afr_mainland, \n     col = (map.pal(\"elevation\", n = 100)),\n     xlim = c(-20, 55), \n     ylim = c(-40, 40))\n\n\n\n\n\n\n\nplot(elev_afr_mainland, \n     col = (terrain.colors(100)),\n     plg = list(title = \"Elevation (m)\",  ## this argument adds a legend\n                cex = 0.8),\n     xlim = c(-20, 55), \n     ylim = c(-40, 40))\n\n\n\n\n\n\n\n\nThe terra package also allows you to plot parts of the ocean surrounding landmasses. Here is an example of how to plot the bathymetry around Africa:\n\n# first create a buffer of 200 km around the continent\nafr &lt;- subset(continents, continents$continent == \"Africa\")\nafr_buff &lt;- terra::buffer(afr, width = 200000)  ## 200km\nafr_buff &lt;- terra::buffer(afr_mainland, width = 200000)  ## 200km\nplot(afr_buff, \n     col = \"darkblue\", \n     background = \"lightblue\",\n     xlim = c(-20, 55), \n     ylim = c(-40, 40))\nplot(afr_mainland, \n     col = \"tan\", \n     add = TRUE,\n     xlim = c(-20, 55), \n     ylim = c(-40, 40))\n\n\n\n\n\n\n\n# import bathymetry\nbathy_source &lt;- \"https://gebco2023.s3.valeria.science/gebco_2023_land_cog.tif\"\nbathy &lt;- terra::rast(bathy_source, vsi = TRUE)  ## rasterize it\n\nafr_bathy &lt;- terra::crop(bathy, \n                         afr_buff, \n                         mask = TRUE)\nplot(afr_bathy, \n     col = hcl.colors(100, \"blues\"),\n     xlim = c(-20, 55), \n     ylim = c(-40, 40))\nplot(countries, \n     col = \"tan\", \n     add = TRUE,\n     xlim = c(-20, 55), \n     ylim = c(-40, 40))\n\n\n\n\n\n\n\nplot(afr_bathy, \n     col = hcl.colors(100, \"blues\"),\n     legend = FALSE,\n     xlim = c(-20, 55), \n     ylim = c(-40, 40))\nplot(elev_afr_mainland, \n     col = (gray(seq(0.9,0.1,length.out = 100))), \n     add = TRUE,\n     xlim = c(-20, 55), \n     ylim = c(-40, 40))\n\n\n\n\n\n\n\n\nFinally, combining the terra and rayshader makes it possible to create 3D maps. Here is an example of the code to create a 3D map of elevation in mainland Africa, that is not run here.\n\n# convert to matrix\nelev_matrix &lt;- as.matrix(elev_afr_mainland,\n                         wide = TRUE)\n# flip vertically for rayshader\nelev_matrix &lt;- elev_matrix[nrow(elev_matrix):1, ]\n\n# create 3D map\nelev_matrix %&gt;%\n  sphere_shade(texture = \"imhof1\") %&gt;%\n  plot_3d(elev_matrix,\n          zscale = 100,\n          fov = 0,\n          theta = -45,\n          zoom = 0.75,\n          phi = 30,\n          windowsize = c(800, 800))\n\n# render snapshot\nrender_snapshot(\"maps/3D_elevation_Africa.png\",\n                title_text = \"Elevation in mainland Africa\",\n                title_size = 20)",
    "crumbs": [
      "Creating Maps in R"
    ]
  },
  {
    "objectID": "gettinghelp.html",
    "href": "gettinghelp.html",
    "title": "Getting help",
    "section": "",
    "text": "The first place to get help with R is the Comprehensive R Archive Network, where you can find many resources about R, such as manuals and FAQs, and also general announcements from the developers.\nDirectly in RStudio you can open the Help page (on the Help tab, usually on the bottom right panel) by running “?” followed by the name of the function or package:\n\n?read.table\n\nIf you cannot remember the exact name of a function, but remember its subject, you can use the help.search() function passing what you remember as an argument.\n\nhelp.search(\"csv\")  ## then use ? read.table for more precise info\n\nThe function find() finds which package a given function is in (more on packages and functions later); apropos() returns the objects and functions that match the argument you pass to it; example() and demo() take function names as arguments and are useful to learn how those functions work.\n\n# Try using those functions\nfind(\"max\")\n\napropos(\"lm\")\n\nexample(lm)\ndemo(graphics)\n\nFinally, knowing the version of R you are using and how to cite it (do not forget to cite it!) are always useful and can be done as follows:\n\nversion\n\n               _                                \nplatform       x86_64-w64-mingw32               \narch           x86_64                           \nos             mingw32                          \ncrt            ucrt                             \nsystem         x86_64, mingw32                  \nstatus                                          \nmajor          4                                \nminor          5.2                              \nyear           2025                             \nmonth          10                               \nday            31                               \nsvn rev        88974                            \nlanguage       R                                \nversion.string R version 4.5.2 (2025-10-31 ucrt)\nnickname       [Not] Part in a Rumble           \n\ncitation()\n\nTo cite R in publications use:\n\n  R Core Team (2025). _R: A Language and Environment for Statistical\n  Computing_. R Foundation for Statistical Computing, Vienna, Austria.\n  &lt;https://www.R-project.org/&gt;.\n\nA BibTeX entry for LaTeX users is\n\n  @Manual{,\n    title = {R: A Language and Environment for Statistical Computing},\n    author = {{R Core Team}},\n    organization = {R Foundation for Statistical Computing},\n    address = {Vienna, Austria},\n    year = {2025},\n    url = {https://www.R-project.org/},\n  }\n\nWe have invested a lot of time and effort in creating R, please cite it\nwhen using it for data analysis. See also 'citation(\"pkgname\")' for\nciting R packages.",
    "crumbs": [
      "Basics in R",
      "Getting help"
    ]
  },
  {
    "objectID": "corReg.html",
    "href": "corReg.html",
    "title": "Correlations and regressions",
    "section": "",
    "text": "Correlation is a statistical measure that can be used to test and describe the extent to which two continuous variables change together. It quantifies the strength and direction of the linear relationship between the variables. The correlation coefficient, often denoted as “r”, ranges from -1 to +1. A value of +1 indicates a perfect positive correlation, meaning that as one variable increases, the other variable also increases proportionally. A value of -1 indicates a perfect negative correlation, meaning that as one variable increases, the other variable decreases proportionally. A value of 0 indicates no correlation, meaning there is no linear relationship between the variables.\nRegression is a statistical method used to examine the relationship between a dependent (response) variable and one or more independent (explanatory) variables, when they are both continues. It helps us understand how changes in the independent variables are associated with changes in the dependent variable. There are different types of regression, including linear regression, multiple regression, and logistic regression, each suited for different types of data and research questions. Here we will cover only linear regressions, which is the simplest and most frequently used type.\nThe basic function of regressions analyses is to estimate parameter values and their standard errors using the data available. The first step is to select a model to describe the relationship between the dependent and independent variables. The most common model is the linear model, which assumes a straight-line relationship between the variables. The general equation for a simple linear regression is:\ny = a + bx where y is the dependent variable, a is the intercept (the value of y when x is 0), b is the slope (the change in y for a one-unit change in x), and x is the independent variable.",
    "crumbs": [
      "Data analysis",
      "Correlations and regressions"
    ]
  },
  {
    "objectID": "corReg.html#correlation",
    "href": "corReg.html#correlation",
    "title": "Correlations and regressions",
    "section": "",
    "text": "Correlation is a statistical measure that can be used to test and describe the extent to which two continuous variables change together. It quantifies the strength and direction of the linear relationship between the variables. The correlation coefficient, often denoted as “r”, ranges from -1 to +1. A value of +1 indicates a perfect positive correlation, meaning that as one variable increases, the other variable also increases proportionally. A value of -1 indicates a perfect negative correlation, meaning that as one variable increases, the other variable decreases proportionally. A value of 0 indicates no correlation, meaning there is no linear relationship between the variables.\nRegression is a statistical method used to examine the relationship between a dependent (response) variable and one or more independent (explanatory) variables, when they are both continues. It helps us understand how changes in the independent variables are associated with changes in the dependent variable. There are different types of regression, including linear regression, multiple regression, and logistic regression, each suited for different types of data and research questions. Here we will cover only linear regressions, which is the simplest and most frequently used type.\nThe basic function of regressions analyses is to estimate parameter values and their standard errors using the data available. The first step is to select a model to describe the relationship between the dependent and independent variables. The most common model is the linear model, which assumes a straight-line relationship between the variables. The general equation for a simple linear regression is:\ny = a + bx where y is the dependent variable, a is the intercept (the value of y when x is 0), b is the slope (the change in y for a one-unit change in x), and x is the independent variable.",
    "crumbs": [
      "Data analysis",
      "Correlations and regressions"
    ]
  },
  {
    "objectID": "boxplotsHistograms.html",
    "href": "boxplotsHistograms.html",
    "title": "Boxplots and histograms",
    "section": "",
    "text": "R includes built-in functions other than plot() for visualizing distributions of data, such as boxplots and histograms. Both boxplots and histograms are useful tools for visualizing the distribution of numeric data, and they can provide insights into the central tendency, spread, and shape of the data. A boxplot (or box-and-whisker plot) summarizes the distribution of a numeric variable by displaying its minimum, first quartile (Q1), median, third quartile (Q3), and maximum. A histogram, on the other hand, shows the frequency distribution of a numeric variable by dividing the data into bins and counting how many observations fall into each bin.\nBoxplots can be created using the boxplot() function. Let’s use the Ferreira et al. (2024) dataset to create a boxplot of the SCL variable:\n\nboxplot(size.meas$SCL, ylab = \"SCL (mm)\")\n\n\n\n\n\n\n\n\nAs for the plot() function, you can customize boxplots by adding titles, changing axis labels, and modifying colors. It is also possible to create boxplots for multiple groups by specifying a formula interface. For example, to create boxplots of SCL grouped by Clade, you can use the following code:\n\nclade.colors &lt;- rainbow(length(unique(size.meas$Clade)))\nboxplot(SCL ~ Clade, data = size.meas, \n        main = \"SCL by Clade\",\n        xlab = \"Clade\",\n        ylab = \"SCL (mm)\",\n        col = clade.colors,\n        cex.axis = 0.6,\n        cex.lab = 0.8)\n\n\n\n\n\n\n\n\nNote that, in this case, we used the formula SCL ~ Clade to specify that the SCL values should be grouped by Clade and defined the dataframe using the data argument. We also created a vector of colors using the rainbow() function to assign different colors to each clade. As for the n argument (number of colors), we used the length() of unique() clades in the dataframe.\nHistograms can be created using the hist() function. Let’s create a histogram of the SCL variable from the same dataset:\n\nhist(size.meas$SCL,\n     main = \"Histogram of SCL\",\n     xlab = \"SCL (mm)\",\n     ylab = \"Frequency\",\n     col = \"lightgray\",\n     border = \"black\")\n\n\n\n\n\n\n\n\nYou can customize histograms by changing the number of bins using the breaks argument, adding titles, and modifying colors. For example, to create a histogram with 20 bins, you can use the following code:\n\nhist(size.meas$SCL,\n     breaks = 20,\n     main = \"Histogram of SCL with 20 Bins\",\n     xlab = \"SCL (mm)\",\n     ylab = \"Frequency\",\n     col = \"lightblue\",\n     border = \"black\")\n\n\n\n\n\n\n\n\nNote that, even though we specified 20 bins using the breaks argument, R may adjust the number of bins slightly to better fit the data (this is explained in the documentation of the function). If you want a specific number of bins, you can define a vector of breakpoints instead. For example, to create a histogram with bins of width 10 mm, you can use the following code:\n\nhist(size.meas$SCL,\n     breaks = seq(0, max(size.meas$SCL, na.rm = TRUE), length.out = 10),\n     main = \"Histogram of SCL with Bins of Width 10 mm\",\n     xlab = \"SCL (mm)\",\n     ylab = \"Frequency\",\n     col = heat.colors(length(seq(0, max(size.meas$SCL, na.rm = TRUE), length.out = 10))),\n     border = \"black\")\n\n\n\n\n\n\n\n\nIn this case, we used the seq() function to create a sequence of breakpoints from 0 to the maximum value of SCL, with a specified number of bins (10 in this case), given as the length.out argument. We also used the heat.colors() function to generate a gradient of colors for the bars in the histogram, using the length of the previous sequence as the number of colors.",
    "crumbs": [
      "Data visualization",
      "Boxplots and histograms"
    ]
  },
  {
    "objectID": "colors.html",
    "href": "colors.html",
    "title": "Colors in plots",
    "section": "",
    "text": "There are different ways of selecting colors for plots in R. So far, we’ve seen the simplest way — but also the most limited — of selecting colors by using their names (e.g., “red”, “blue”, “green”, etc.). R has a set of predefined color names that you can use in your plots. You can see the full list of color names by running the colors() function:\n\nhead(colors(), n = 20)  ## show first 20 color names\n\n [1] \"white\"         \"aliceblue\"     \"antiquewhite\"  \"antiquewhite1\"\n [5] \"antiquewhite2\" \"antiquewhite3\" \"antiquewhite4\" \"aquamarine\"   \n [9] \"aquamarine1\"   \"aquamarine2\"   \"aquamarine3\"   \"aquamarine4\"  \n[13] \"azure\"         \"azure1\"        \"azure2\"        \"azure3\"       \n[17] \"azure4\"        \"beige\"         \"bisque\"        \"bisque1\"      \n\n\nThe rgb() function allows you to create custom colors by specifying the red, green, and blue components of the color. Each component can take a value between 0 and 255. For example, to create a custom purple color, you can use:`\n\ncustom.purple &lt;- rgb(128, 0, 128, maxColorValue = 255)\ncustom.purple\n\n[1] \"#800080\"\n\nplot(1, 1, \n     col = custom.purple, \n     pch = 19, \n     cex = 20,\n     xaxt = 'n',  ## removes x axis\n     yaxt = 'n',  ## removes y axis\n     xlab = \"\",\n     ylab = \"\",\n     bty = \"n\")  ## removes box around the plot\n\n\n\n\n\n\n\n\nYou can also create colors using hexadecimal color codes. A hexadecimal color code is a six-digit code that represents the red, green, and blue components of a color. For example, the hexadecimal color code for pink is “#ff00ff”. You can use this code directly in your plots:\n\nplot(1, 1,\n     col = \"#ff00ff\", \n     pch = 19, \n     cex = 20,\n     xaxt = 'n', \n     yaxt = 'n', \n     xlab = \"\",\n     ylab = \"\",\n     bty = \"n\") \n\n\n\n\n\n\n\n\nAnother way to select colors is by using the hsv() function, which allows you to create colors based on their hue, saturation, and value (brightness). The hue component represents the color itself, the saturation component represents the intensity of the color, and the value component represents the brightness of the color. Each component can take a value between 0 and 1. For example, to create a custom orange color, you can use:\n\ncustom.orange &lt;- hsv(h = 30/360, s = 1, v =\n 1)\ncustom.orange\n\n[1] \"#FF8000\"\n\nplot(1, 1,\n     col = custom.orange,\n     pch = 19,\n     cex = 20,\n     xaxt = 'n',\n     yaxt = 'n',\n     xlab = \"\",\n     ylab = \"\",\n     bty = \"n\")\n\n\n\n\n\n\n\n\nAnother nice feature is adding transparency to colors using the adjustcolor() function. This function allows you to adjust the transparency of a color by specifying an alpha value between 0 (completely transparent) and 1 (completely opaque). For example, to create a semi-transparent red color, you can use:\n\npar(mfrow = c(1,3)) \ncolors.vector &lt;- c(adjustcolor(custom.purple, alpha.f = 0.5),\n                   adjustcolor(\"#ff00ff\", alpha.f = 0.5),\n                   adjustcolor(custom.orange, alpha.f = 0.5))\ncolors.vector\n\n[1] \"#80008080\" \"#FF00FF80\" \"#FF800080\"\n\nfor (i in 1:3) {\n  plot(1, 1,\n     col = colors.vector[i],\n     pch = 19,\n     cex = 20,\n     xaxt = 'n',\n     yaxt = 'n',\n     xlab = \"\",\n     ylab = \"\",\n     bty = \"n\")\n}\n\n\n\n\n\n\n\n\nYou can also use built-in color palettes in R, such as the rainbow(), heat.colors(), terrain.colors(), and topo.colors() functions. These functions generate a sequence of colors based on a specific color scheme. For example, to create a rainbow color palette with 10 colors, you can use:\n\nrainbow.colors &lt;- rainbow(10)\n\npar(mfrow = c(2,5), mai = c(0.3,0.3,0.3,0.3))  \n\nfor (i in 1:10) {\n    plot(1, 1,\n     col = rainbow.colors[i],\n     pch = 19,\n     cex = 15,\n     xaxt = 'n',\n     yaxt = 'n',\n     xlab = \"\",\n     ylab = \"\",\n     bty = \"n\")\n}\n\n\n\n\n\n\n\n\nYou can use these colors in your plots by specifying them in the col argument. For example, let’s create a scatter plot using the rainbow color palette:\n\nsetwd(\"d:/R Projects/Intro-to-R/datasets/Ferreira_etal-2024\")\nsize.meas &lt;- read.csv(\"size-meas.csv\", sep = \",\", header = TRUE)\nplot(size.meas$JL, size.meas$SCL,\n     xlim = c(15,95), \n     ylim = c(80,610),\n     xlab = \"JL (mm)\",\n     ylab = \"SCL (mm)\",\n     main = \"Jaw Length vs. Carapace Length\",\n     sub = \"Published data from Ferreira et al. (2024). Biol. Lett.\",\n     bty = \"l\",\n     col = rainbow.colors,\n     pch = 19,\n     cex = 1.5,\n     cex.main = 1.2,\n     cex.sub = 0.6,\n     cex.lab = 0.8,\n     cex.axis = 0.8)\n\n\n\n\n\n\n\n\nIn this example, the colors are assigned based on the order of the points in the dataset (i.e., row 1 gets position one in rainbow.colors object, row 2 gets position 2 and so on). You can customize the color assignment based on your specific needs. For example, you can assign colors based on a categorical variable in your dataset, such as the Clade of the turtles. This way, each clade will have a different color in the plot. Here is an example using the terrain.colors pallete:\n\nclade.colors &lt;- terrain.colors(length(unique(size.meas$Clade)))\nnames(clade.colors) &lt;- unique(size.meas$Clade)\npoint.colors &lt;- clade.colors[size.meas$Clade]\nplot(size.meas$JL, size.meas$SCL,\n     xlim = c(15,95), \n     ylim = c(80,610),\n     xlab = \"JL (mm)\",\n     ylab = \"SCL (mm)\",\n     main = \"Jaw Length vs. Carapace Length\",\n     sub = \"Published data from Ferreira et al. (2024). Biol. Lett.\",\n     bty = \"l\",\n     col = point.colors,\n     pch = 19,\n     cex = 1.5,\n     cex.main = 1.2,\n     cex.sub = 0.6,\n     cex.lab = 0.8,\n     cex.axis = 0.8)\n\nlegend(\"topleft\", \n       legend = names(clade.colors), \n       col = clade.colors, \n       pch = 19, \n       cex = 0.6,\n       bty = \"n\")",
    "crumbs": [
      "Data visualization",
      "Colors in plots"
    ]
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Functions",
    "section": "",
    "text": "Using functions is a great way to generalize and automatize processes. R comes with several basic functions implemented in packages (which are basic collections of functions and objects) such as stats and graphics. Functions will usually take arguments provided by the user based on which they will perform an action. It is always important to read the Help page of a function to learn which arguments are possible and how to use them.\nFor example, you can use a function to generate a sequence more complex than just by using 1:10 using the arguments by and length.out of the function seq():\n\nseq(from = 1, to = 20, by = 2)  ## increment the sequence by 2\n\n [1]  1  3  5  7  9 11 13 15 17 19\n\nseq(from = 1, to = 20, length.out = 5)  ## only 5 numbers between 1 and 20\n\n[1]  1.00  5.75 10.50 15.25 20.00\n\n\nA sequence can also be created by repetitions using the function rep() and defining arguments as each (each element is repeated x times) and times (the sequence is repeated x times).\n\nrep(1:4, each = 2)\n\n[1] 1 1 2 2 3 3 4 4\n\nrep(c(\"cat\", \"dog\", \"mouse\"), times = 2)\n\n[1] \"cat\"   \"dog\"   \"mouse\" \"cat\"   \"dog\"   \"mouse\"\n\nrep(c(\"cat\", \"dog\", \"mouse\"), times = 1:3)\n\n[1] \"cat\"   \"dog\"   \"dog\"   \"mouse\" \"mouse\" \"mouse\"\n\n\nWe saw before that a logical operation can be made for each element in a vector using logical operators. If you want to check whether all() or any() elements fit a certain criterium you can use the functions:\n\nvec.1 &lt;- c(2, 4, 6)\nall(vec.1&lt;4)\n\n[1] FALSE\n\nany(vec.1&lt;4)\n\n[1] TRUE\n\n\nThe base packages in R also include functions to perform more complex but very useful calculations, such as logarithms (with different bases) and antilogs, square roots, sums, means and medians.\n\nlog(42)  ## natural log\n\n[1] 3.73767\n\nlog10(42)  ## base 10 log\n\n[1] 1.623249\n\nexp(3.73767)  ## antilog\n\n[1] 42.00002\n\nX = 13^2\nsqrt(X) == 13\n\n[1] TRUE\n\nvec &lt;- seq(1, 100, by = 2)\nsum(vec)\n\n[1] 2500\n\nmean(vec)\n\n[1] 50\n\nmedian(vec)\n\n[1] 50\n\n\nChecking the range of values in a list, the minimum and maximum values, and the length of this list can be very useful. As well as sorting a list or selecting which values correspond to a criterium.\n\nrange(vec)\n\n[1]  1 99\n\nmax(vec)\n\n[1] 99\n\nmin(vec)\n\n[1] 1\n\nlength(vec)\n\n[1] 50\n\nsort(vec)\n\n [1]  1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49\n[26] 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99\n\nrev(vec)\n\n [1] 99 97 95 93 91 89 87 85 83 81 79 77 75 73 71 69 67 65 63 61 59 57 55 53 51\n[26] 49 47 45 43 41 39 37 35 33 31 29 27 25 23 21 19 17 15 13 11  9  7  5  3  1\n\nwhich(vec == 3)  ## gives the position in the list\n\n[1] 2\n\n\nWe saw before how to see the class of an object using the class() function, but we can also check whether an object is from a specific class using the group of functions is.X:\n\nis.numeric(vec)\n\n[1] TRUE\n\nis.character(vec)\n\n[1] FALSE\n\n\nFactor is an object type that represent categorical variables. They have a determined number levels (categories), and some functions can be used to check those.\n\ncolor.names &lt;- factor(c(\"black\", \"white\", \"pink\", \"pink\", \"white\", \"white\"))\nclass(color.names)\n\n[1] \"factor\"\n\nlength(color.names)\n\n[1] 6\n\nlevels(color.names)\n\n[1] \"black\" \"pink\"  \"white\"\n\nlength(levels(color.names))\n\n[1] 3\n\n# there is also a function to do that\nnlevels(color.names)\n\n[1] 3\n\n\nLet’s say you want to calculate the mean value of a sequence that contains NA. This will return an NA:\n\ny &lt;- c(4, NA, 7)\nmean(y)\n\n[1] NA\n\n\nSo, you need to deal with this NA before obtaining this mean value. You can identify its position and manually remove it, but this becomes impracticable as the dimensions of an object increase. You can replace the NA by another value, using the ifelse() function, but that will change the original data. Alternatively, you can omit the NAs from the calculation, either before (using the function na.omit()) or with an argument implemented in the mean() function:\n\n# Option 1. Manually removing NAs. Try to understand the series of code here\nis.na(y)  ## tells you which positions are NAs\n\n[1] FALSE  TRUE FALSE\n\ny[!is.na(y)]\n\n[1] 4 7\n\ny.removed &lt;- y[!is.na(y)]  \ny.removed\n\n[1] 4 7\n\nmean(y.removed)\n\n[1] 5.5\n\n# Option 2. Replacing NAs\ny.replaced &lt;- ifelse(test = is.na(y), yes = 0, no = y) \ny.replaced\n\n[1] 4 0 7\n\nmean(y.replaced)\n\n[1] 3.666667\n\n# Option 3. Omitting NAs\ny.omit &lt;- na.omit(y)\ny.omit\n\n[1] 4 7\nattr(,\"na.action\")\n[1] 2\nattr(,\"class\")\n[1] \"omit\"\n\nmean(y.omit)\n\n[1] 5.5\n\n# Option 4. Use an argument in mean()\nmean(y, na.rm = TRUE)\n\n[1] 5.5\n\n\nOn the next section we will see how you can write your own function.\n\nPackages\nIn this section we will install and load packages to use their functions. Packages available on the official R repository (the CRAN repository) can be installed using the function:\n\ninstall.packages(\"ggplot2\")\n\nInstalling a package does not make it readily available, they first need to be loaded on the session.\n\nlibrary(ggplot2)",
    "crumbs": [
      "Basics in R",
      "Functions"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction To R",
    "section": "",
    "text": "Welcome to the website of the Introduction to R course (Geow-M317_325-21-16). This short course is part of the Data Analysis and Modeling Methods in Geoscience and Environmental Science module of the Geosciences Department (Uni. Tübingen) and is developed and taught by Gabriel Ferreira.\nThe Intro to R course aims to provide a brief introduction to using the R programming language and environment in a data science context, particularly for students in the areas of Geology and Palaeontology. With a lot of hands-on exercises, the students are expected to feel comfortable to use and explore the many possibilities provided by R.\nYou can use the sidebar to navigate through the different code presented in each day of the course.\nWe will use the RStudio integrated development environment (IDE) for R during this course. You can either install on your own machine or create a free account to use the cloud version of it (but keep in mind that the computing power and hours are limited with the free account, so this might not be enough — particularly in the last days of the course). Make sure to update R (https://cran.r-project.org/bin/windows/base/) and RStudio (https://posit.co/download/rstudio-desktop/) as this page will be kept up-to-date using the latest version.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "objects.html",
    "href": "objects.html",
    "title": "Objects and variables",
    "section": "",
    "text": "Of course R is more than a simple calculator. The great benefit of using such a language is being able to store the results of an operation into a variable (or an object) that can be used later in some subsequent operation or passed as an argument in a function. In R you can do that using either &lt;- (which passes the value from the right to the left; shortcut: Alt + -) or the =. They have the same effect, but keeping the usage of = for operations or passing a value as an argument and &lt;- for storing values in an object is usually better seen. Whatever you choose to use, keep it consistent.\nAn object in R is stored in the environment and can be accessed by just typing its name. An object can store anything, a number, a character string, a vector or list, a matrix or data frame, even functions. Keep in mind that R is case-sensitive! The class of an object can be checked using the class() function.\n\nY = 2\ny = 1\nY == y\n\n[1] FALSE\n\nclass(y)\n\n[1] \"numeric\"\n\nanswer = \"Y is not the same as y\"\nanswer\n\n[1] \"Y is not the same as y\"\n\nclass(answer)\n\n[1] \"character\"\n\nsequence &lt;- 1:10\nsequence\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nclass(sequence)\n\n[1] \"integer\"\n\nclass(class)\n\n[1] \"function\"\n\n\nOperations can be done with objects instead of numbers (such as Y == y above). You can also combine objects into different objects. For example, to create a matrix (2-dimensions object), you can combine two vectors (1D objects) using functions like rbind() or cbind() (check their Help pages using ?rbind. Check also the function c()).\n\nvec.1 &lt;- c(2, 4, 6)\nvec.2 &lt;- c(3, 5, 7)\nmatrix.1 &lt;- cbind(vec.1, vec.2)  ## binds by column\nmatrix.1\n\n     vec.1 vec.2\n[1,]     2     3\n[2,]     4     5\n[3,]     6     7\n\nmatrix.2 &lt;- rbind(vec.1, vec.2)  ## binds by row\nmatrix.2\n\n      [,1] [,2] [,3]\nvec.1    2    4    6\nvec.2    3    5    7\n\nvec.1 + vec.2\n\n[1]  5  9 13\n\nvec.1 &gt; 4\n\n[1] FALSE FALSE  TRUE\n\n\nThere is another class of objects in R called data frames that are used a lot by many functions due to its capacity of storing different data types and to have your dimensions changed after creation. For example, you cannot have one column with character strings and another with numbers in a matrix (it will convert the columns to the same type), but you can have that with a data frame. You can access single columns, rows or cells by using the row and/or column number between square brackets.\n\nvec.3 = c(\"A\", \"B\", \"C\")\ncbind(vec.3, vec.2)\n\n     vec.3 vec.2\n[1,] \"A\"   \"3\"  \n[2,] \"B\"   \"5\"  \n[3,] \"C\"   \"7\"  \n\ndf &lt;- data.frame(vec.3, vec.2)\ndf\n\n  vec.3 vec.2\n1     A     3\n2     B     5\n3     C     7\n\ndf[1,1]  ## row 1, column 1\n\n[1] \"A\"\n\ndf[,2]  ## column 2\n\n[1] 3 5 7\n\n\nA nice feature of a data frame is giving names to its columns and then calling them using the $ sign.\n\ncolnames(df) &lt;- c(\"characters\", \"numbers\")\ndf$characters\n\n[1] \"A\" \"B\" \"C\"\n\ndf$numbers\n\n[1] 3 5 7\n\n\nAnother type of objects in R is called factors. Factors are categorical variables that can take a limited number of values (levels). Factors are useful in statistical modeling because they allow R to treat categorical variables appropriately. You can create a factor using the factor() function.\n\nobj.colors = factor(c(\"black\", \"white\", \"black\", \"black\", \"pink\", \"white\")) \nclass(obj.colors)\n\n[1] \"factor\"\n\n\nFactors have levels, which are the unique values that the factor can take. The number of levels is not the same as the number of positions in a factor object, because a value can be repeated in more than one position.\n\nlength(obj.colors)\n\n[1] 6\n\nlevels(obj.colors)\n\n[1] \"black\" \"pink\"  \"white\"\n\nnlevels(obj.colors)  ## nlevels() gives the number of levels, same as length(levels())\n\n[1] 3",
    "crumbs": [
      "Basics in R",
      "Objects and variables"
    ]
  },
  {
    "objectID": "paleomaps.html",
    "href": "paleomaps.html",
    "title": "Paleogeographic maps in R",
    "section": "",
    "text": "Now that we have explored how to create maps and to download and plot occurrence data from the Paleobiology Database using R, let’s take a look at how to create paleogeographic maps.\nPaleogeographic maps are reconstructions of the Earth’s surface at different points in geological time, showing the distribution of landmasses, oceans, and other features. GPlates is a program that enables users to model different geologic variables, including plate tectonics, into present and past maps. GPlates has a web service that provides access to various paleogeographic reconstructions that can be used in R. The first step is to download the data using a function from the sf package called st_read(). In this example, we will download a database of the coastlines (which can be used to reconstruct the continents) during the Late Cretaceous, more precisely, from 72 million years ago, using and plot it using the terra package. Such reconstructions are based on paleogeographical models and, in this example, we are going to specify the GOLONKA model, based on the Wright et al. 2013 publication.\n\n# first define an object containing the URL of the reconstruction\npaleocoastlines.url &lt;- \"http://gws.gplates.org/reconstruct/coastlines/?time=72&model=GOLONKA\"\n\n# then use st_read() to download it\npaleocoastlines &lt;- st_read(paleocoastlines.url)\n\n# simple plot to check it\nplot(paleocoastlines)\n\n\n\n\n\n\n\n\nThe object paleocoastlines is a simple features (sf) object that can be converted to a SpatVector object from the terra package using the function vect(). This allows us to use the plotting capabilities of the terra package to create more customized maps, such as adding colors and changing the borders’ width. Let’s convert the object and plot it using terra:\n\n# convert to SpatVector\npaleocoastlines.terra &lt;- vect(paleocoastlines)\n# plot using terra\nplot(paleocoastlines.terra,\n     col = \"tan\",\n     border = \"saddlebrown\",\n     lwd = 0.5,\n     main = \"Maastrichtian Paleomap - GOLONKA\n\")\n\n\n\n\n\n\n\n\nWe can also use the original sf object to create maps using the ggplot2 package. This allows us to take advantage of the powerful plotting capabilities of ggplot2 to create more complex and visually appealing maps. Let’s see how to do that:\n\nlibrary(ggplot2)\n\nggplot() +\n  geom_sf(data = paleocoastlines, fill = \"grey80\", color = \"black\") +\n  labs(title = \"Maastrichtian Paleomap - GOLONKA\") \n\n\n\n\n\n\n\n\nAnd, finally, we can of course add occurrence data to our paleogeographic maps. However, it is important to note that the coordinates of the occurrences need to be “paleoreconstructed” to match the time period of the paleomap. This can be done using various methods, such as using plate tectonic models or software like GPlates. Once the coordinates are reconstructed, we can plot them on top of the paleogeographic map using either terra or ggplot2.\n\nlibrary(paleobioDB)\n\n# download Dinosauria occurrences from the Maastrichtian\ndinosaurs.maastr &lt;- pbdb_occurrences(base_name = \"Dinosauria\",\n                                     interval = \"Maastrichtian\",\n                                     show = c(\"coords\", \"classext\", \"paleoloc\"),\n                                     limit = \"all\", \n                                     vocab = \"pbdb\",\n                                     pgm = \"gplates\")\n# plot using terra\nplot(paleocoastlines.terra,\n     col = \"tan\",\n     border = \"saddlebrown\",\n     lwd = 0.5,\n     main = \"Maastrichtian Paleomap with Dinosauria occurrences - GOLONKA\")\npoints(dinosaurs.maastr$paleolng,\n       dinosaurs.maastr$paleolat,\n       pch = 21,\n       bg = \"purple\",\n       cex = 0.7)\n\n\n\n\n\n\n\n# plot using ggplot2\nggplot() +\n  geom_sf(data = paleocoastlines, fill = \"grey80\", color = \"black\") +\n  labs(title = \"Maastrichtian Paleomap with Dinosauria occurrences - GOLONKA\")+\n  theme_minimal() +\n  geom_point(data = dinosaurs.maastr,\n             aes(x = paleolng, y = paleolat),\n             colour = \"purple\",\n             alpha = 0.3,\n             show.legend = FALSE)",
    "crumbs": [
      "Paleogeographic maps in R"
    ]
  },
  {
    "objectID": "quarto.html",
    "href": "quarto.html",
    "title": "Creating documents in R - Quarto",
    "section": "",
    "text": "Quarto is a multi-language version of R Markdown (a file format for making dynamic documents with R) that allows you to easily create and render different types of documents in R, such as PDFs, .doc and .html files. Quarto files are saved with the extension .qmd. Quarto enables the usage of code blocks in the rendering that allows you to create fully reproducible documents by including links to the actual data and the code used to produce the output analyses or plots.\nThis page is based in the tutorials available on the official Quarto website. Access that page for a more detailed tutorial.\nDownload this Quarto document, open it in RStudio, and click on the  Render button.\nRStudio offers two ways of viewing and working with .qmd files: Source and Visual editors. In the Visual editor you see the file more similar to the way it will be rendered and can use the toolbar to format its content, whereas in the Source editor, you can edit the source code directly.\n\nRendering\nUse the  Render button in RStudio to render the file and preview the output with a single click. You can also use a keyboard shortcut (Ctrl + Shift + K in Windows or ⇧⌘K an Mac OS).\nWhen rendering, Quarto creates a new file that contains selected text, code, and results from the .qmd file. That file can be in many formats, including HTML and PDF.\nOpen the file you just downloaded to explore its contents.\n\n\nParts of a .qmd file\nMost of a Quarto file can be made of simple text, including formatting using Markdown notation. However, the power of Quarto comes from incorporating code in different languages that can transform the final document. Among those, we can cite the YAML header and code chunks in the text.\n\nYAML header\nAn optional YAML header is defined by three dashes (—) on both ends.\n\n---\ntitle: \"Hello, Quarto\"\nformat: html\neditor:visual\n---\n\nIn the rendered document, the title will appear at its top with a larger font size than the rest of the document. The format command denotes the format of the final document (in the example above, html, but it can be PDF or doc, for example). For each of those formats, there are several other YAML fields that can be added to the header (editor in the example denotes that the output should be open in the visual editor by default), such as author, subtitle, date, theme, and fontcolor.\n\n\nCode chunks\nCode chunks in a Quarto file can be used for many purposes, such as plotting figures or creating tables. Quarto accepts different programming languages in such chunks, for example python and, most important for our course, R. Code chunks are denote by three backticks (`) on both ends.\nR code chunks are identified by {r} with optional options, in YAML style, identified by #| at the beginning of the line.\n\n```{r}\n#| label: load-packages\n#| include: false\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n```\n\nIn this case, the label of the chunk is load-packages and we set include to false to indicate that we do not want the chunk itself or any of its outputs in the rendered document. There are many other options that can be used to tailor code chunks. For example, by default the code and its output are displayed within the rendered document, but setting echo and output to false omits both the commands and results from the document. Here are two examples, first including the source code:\n\nlibrary(ggplot2)\n\nggplot(mpg, aes(x = hwy, y = cty, color = cyl)) +\n  geom_point(alpha = 0.5, size = 2) +\n  scale_color_viridis_c() +\n  theme_minimal()\n\n\n\n\n\n\n\n\nAnd omitting it:\n\n\n\n\n\n\n\n\n\nIt is also possible to improve the appearance and accessibility of plots in the rendered file, by changing its dimensions, providing a caption, or adding alternative texts. We can also add multiple figures in the same plot. Let’s add the following chunk options and a second figure to our previous plot and compare the differences:\n\n```{r}\n#| label: fig-scatterplot\n#| fig-cap: \"City and highway mileage for 38 popular models of cars.\"\n#| fig-alt: \"The plots in @fig-mpg show the relationship between city and highway mileage for 38 popular models of cars. In @fig-mpg-1 the points are colored by the number of cylinders while in @fig-mpg-2 the points are colored by engine displacement.\"\n#| fig-subcap:\n#|   - \"Color by number of cylinders\"\n#|   - \"Color by engine displacement, in liters\"\n#| layout-ncol: 2\n#| fig-height: 5\n#| echo: false\n```\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Color by number of cylinders\n\n\n\n\n\n\n\n\n\n\n\n(b) Color by engine displacement, in liters\n\n\n\n\n\n\n\nFigure 1: City and highway mileage for 38 popular models of cars.\n\n\n\n\n\n\nPDFs\nIn order to create PDFs using Quarto you will need to install a recent distribution of LaTeX. TinyTeX is commonly recommended and can be installed in the RStudio Terminal using:\n\nquarto install tinytex\n\nIn order to explore different option to create a PDF you can download the file authoring.qmd. After installing a LaTeX distribution you should be able to render it and create a PDF document with the results. In the third Quarto tutorial you can find out about additional elements of a document, such as creating cross references or citations.",
    "crumbs": [
      "Creating documents with R"
    ]
  },
  {
    "objectID": "savingPlots.html",
    "href": "savingPlots.html",
    "title": "Saving plots",
    "section": "",
    "text": "Once you have created a plot in R, you may want to save it for future use or to include it in a report or presentation. R provides several functions to save plots in different formats, such as PNG, JPEG, PDF, and SVG. Let’s create a simple plot and save it as PNG (image) and PDF (vectorized) formats.\n\nplot(1:10, 1:10, main = \"My Plot\", xlab\n     = \"X-axis\", ylab = \"Y-axis\")\n\n\n\n\n\n\n\n\nTo save a plot as a PNG file, you can use the png() function to specify the file name and dimensions, followed by the plotting commands, and then use the dev.off() function to close the device and save the file. Here’s an example:\n\n# Create a PNG file\npng(\"my_plot.png\", width = 800, height = 600)\n# Create a simple plot\nplot(1:10, 1:10, main = \"My Plot\", xlab\n     = \"X-axis\", ylab = \"Y-axis\")\n# Close the device\ndev.off()\n\nTo save a plot as a PDF file, you can use the pdf() function in a similar way:\n\npdf(\"my_plot.pdf\", width = 8, height = 6)\n\nplot(1:10, 1:10, main = \"My Plot\", xlab\n     = \"X-axis\", ylab = \"Y-axis\")\n# Always close the device\ndev.off()\n\nThese commands will create two files, my_plot.png and my_plot.pdf, in your working directory. You can adjust the width and height parameters to change the size of the saved plots as needed.",
    "crumbs": [
      "Data visualization",
      "Saving plots"
    ]
  },
  {
    "objectID": "syntax.html",
    "href": "syntax.html",
    "title": "Basic syntax",
    "section": "",
    "text": "To use R you need to pass a series of commands to the console that will perform the analyses you want. Instead of just remembering everything you’ve done and typing the commands directly on the console, it is useful to use a text editor and create a script, in which you can keep track of what you want to do. RStudio has a built-in text editor that highlights the different elements used in R language, so it can be very useful. With it you can type all the functions and commands you need and save them in a .R script format. But you can also use any other text editors you like and have your script saved as a .txt file instead. As long as you pass the commands to the console, everything is fine. From now one, we will be using the RStudio text editor.\nEverything you type in the script can be interpreted either as code, unless you tag it as code:\n\n# This is how you type a comment. The following is code:\n\n2 + 2\n\n[1] 4\n\n\nCode should be thought and written in a self-explanatory manner. But, at least when you are learning, commenting your code will be very helpful to remember what (and how) you did before. It is also very useful to keep a cohesive and clean code. Use for example a series of hashtag (#) to create section breakers with titles, and also try to avoid very long lines, breaking the code when possible.\n\n################################################################################\n# This is a new section\n\n# Instead of writing like this:\nplot(x = SCL, y = SCm, log = \"xy\", main = \"Skull vs. carapace length in Chelidae\", xlab = \"Carapace length (SCL)\", ylab = \"Skull lenght (SCm)\", bty = \"l\", cex = 0)\n\n# Try like this\nplot(x = SCL, \n     y = SCm, \n     log = \"xy\", \n     main = \"Skull vs. carapace length in Chelidae\",\n     xlab = \"Carapace length (SCL)\",\n     ylab = \"Skull lenght (SCm)\", \n     bty = \"l\",\n     cex = 0)",
    "crumbs": [
      "Basics in R",
      "Basic syntax"
    ]
  }
]