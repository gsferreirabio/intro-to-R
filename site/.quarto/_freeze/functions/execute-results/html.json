{
  "hash": "543784eb48c544af378e9b90b92a7009",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Functions\"\n---\n\nUsing functions is a great way to generalize and automatize processes. R comes with several basic functions implemented in packages (which are basic collections of functions and objects) such as *stats* and *graphics*. Functions will usually take arguments provided by the user based on which they will perform an action. It is always important to read the Help page of a function to learn which arguments are possible and how to use them.\n\nFor example, you can use a function to generate a sequence more complex than just by using 1:10 using the arguments *by* and *length.out* of the function *seq*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from = 1, to = 20, by = 2)  ## increment the sequence by 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  3  5  7  9 11 13 15 17 19\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(from = 1, to = 20, length.out = 5)  ## only 5 numbers between 1 and 20\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.00  5.75 10.50 15.25 20.00\n```\n\n\n:::\n:::\n\n\nA sequence can also be created by repetitions using the function *rep* and defining arguments as *each* (each element is repeated *x* times) and *times* (the sequence is repeated *x* times).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(1:4, each = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 2 2 3 3 4 4\n```\n\n\n:::\n\n```{.r .cell-code}\nrep(c(\"cat\", \"dog\", \"mouse\"), times = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"cat\"   \"dog\"   \"mouse\" \"cat\"   \"dog\"   \"mouse\"\n```\n\n\n:::\n\n```{.r .cell-code}\nrep(c(\"cat\", \"dog\", \"mouse\"), times = 1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"cat\"   \"dog\"   \"dog\"   \"mouse\" \"mouse\" \"mouse\"\n```\n\n\n:::\n:::\n\n\nWe saw before that a logical operation can be made for each element in a vector using logical operators. If you want to check whether *all* or *any* elements fit a certain criterium you can use the functions:\n\n::: {.cell}\n\n```{.r .cell-code}\nvec.1 <- c(2, 4, 6)\nall(vec.1<4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nany(vec.1<4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nThe base packages in R also include functions to perform more complex but very useful calculations, such as logarithms (with different bases) and antilogs, square roots, sums, means and medians.\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(42)  ## natural log\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.73767\n```\n\n\n:::\n\n```{.r .cell-code}\nlog10(42)  ## base 10 log\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.623249\n```\n\n\n:::\n\n```{.r .cell-code}\nexp(3.73767)  ## antilog\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 42.00002\n```\n\n\n:::\n\n```{.r .cell-code}\nX = 13^2\nsqrt(X) == 13\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nvec <- seq(1, 100, by = 2)\nsum(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2500\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 50\n```\n\n\n:::\n\n```{.r .cell-code}\nmedian(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 50\n```\n\n\n:::\n:::\n\nChecking the range of values in a list, the minimum and maximum values, and the length of this list can be very useful. As well as sorting a list or selecting which values correspond to a criterium.\n\n::: {.cell}\n\n```{.r .cell-code}\nrange(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1 99\n```\n\n\n:::\n\n```{.r .cell-code}\nmax(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 99\n```\n\n\n:::\n\n```{.r .cell-code}\nmin(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 50\n```\n\n\n:::\n\n```{.r .cell-code}\nsort(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49\n[26] 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99\n```\n\n\n:::\n\n```{.r .cell-code}\nrev(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 99 97 95 93 91 89 87 85 83 81 79 77 75 73 71 69 67 65 63 61 59 57 55 53 51\n[26] 49 47 45 43 41 39 37 35 33 31 29 27 25 23 21 19 17 15 13 11  9  7  5  3  1\n```\n\n\n:::\n\n```{.r .cell-code}\nwhich(vec == 3)  ## gives the position in the list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\nWe saw before how to see the class of an object using the *class()* function, but we can also check whether an object is from a specific class using the group of functions \"is.X\":\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.character(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n**Factor** is an object type that represent categorical variables. They have a determined number *levels* (categories), and some functions can be used to check those.\n\n::: {.cell}\n\n```{.r .cell-code}\ncolor.names <- factor(c(\"black\", \"white\", \"pink\", \"pink\", \"white\", \"white\"))\nclass(color.names)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(color.names)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(color.names)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"black\" \"pink\"  \"white\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(levels(color.names))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# there is also a function to do that\nnlevels(color.names)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\nLet's say you want to calculate the mean value of a sequence that contains NA. This will return an NA: \n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(4, NA, 7)\nmean(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\nSo, you need to deal with this NA before obtaining this mean value. You can identify its position and manually remove it, but this becomes impracticable as the dimensions of an object increase. You can replace the NA by another value, using the ifelse() function, but that will change the original data. Alternatively, you can omit the NAs from the calculation, either before (using the function na.omit()) or with an argument implemented in the mean() function:\n\n::: {.cell}\n\n```{.r .cell-code}\n# Option 1. Manually removing NAs. Try to understand the series of code here\nis.na(y)  ## tells you which positions are NAs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ny[!is.na(y)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 7\n```\n\n\n:::\n\n```{.r .cell-code}\ny.removed <- y[!is.na(y)]  \ny.removed\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 7\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(y.removed)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n\n```{.r .cell-code}\n# Option 2. Replacing NAs\ny.replaced <- ifelse(test = is.na(y), yes = 0, no = y) \ny.replaced\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 0 7\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(y.replaced)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.666667\n```\n\n\n:::\n\n```{.r .cell-code}\n# Option 3. Omitting NAs\ny.omit <- na.omit(y)\ny.omit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 7\nattr(,\"na.action\")\n[1] 2\nattr(,\"class\")\n[1] \"omit\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(y.omit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n\n```{.r .cell-code}\n# Option 4. Use an argument in mean()\nmean(y, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n:::\n\nOn the next section we will see how you can write your own function.\n\n### Packages\n\nIn this section we will install and load packages to use their functions.\nPackages available on the official R repository (the CRAN repository) can be installed using the function:\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"ggplot2\")\n```\n:::\n\n\nInstalling a package does not make it readly available, they first need to be loaded on the session. \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n```\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}